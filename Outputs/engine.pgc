/*
 * File - "engine.cpp"
 * Desc - This is the EMF query process engine program for our project.
 * Team - SDE(Stevens Dota Elites/Software Development Engineers).
 * Memb - Gong Cheng 	10390440
 *	  Lingzhi Yuan	10391683
 *	  Yanjun Wu	10392467
 *	  Zhe Xu	10393213
 *
 * Steps to run this program : 
 *  1. Preprocessor 		- $ ecpg -I /usr/include/postgresql engine.pgc
 *  2. Compile     		- $ g++ -c -I /usr/include/postgresql/ engine.c
 *  3. Link        		- $ g++ -L /usr/include/postgresql/ engine.o -lecpg -o engine
 *  4. Execute			- $ ./engine <EMFquery.txt >program.pgc	(The program.pgc file is the output program file that generated by 
 *									our engine, you can change the name if you want, but don't change
 *								 	the extension. If you want to type the input manually, use the 
 *									command without specifying the input, i.e. ./a.out >program.pgc. 
 *									Otherwise specify the input file, i.e. ./a.out <EMFquery.txt >program.pgc.)
 *  5. Run program		- read the instructions in the program file
 */

//--------------------------------------
// c++ including libraries (all standard libraries)
//--------------------------------------
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <cctype>	//used for transfering lower case to upper case
#include <algorithm>
//--------------------------------------
// c including libraries (all standard libraries)
//--------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//--------------------------------------

using namespace std;

//--------------------------------------
// global variables declare
//--------------------------------------
string s,n,v,f,o,g,w; // store the whole line of each operand
vector<string> vecO; //
vector<string> S,V,F,G,W; // seperate the whole line information into vector
int N; // the number of grouping variables
vector< vector<string> > VECO; // the two dimension vector for the range of grouping variables (VECO[0][0] means the 
				// first condition of the first grouping variable)
string tableName; // store the table name of the query
vector<string> columnsName;// store the column names which would be used in the query
vector<string> dataType; // store the type of each column
vector< vector<int> > aggrPrior; // store the scan order for the grouping variables
vector<string> hashPara; // store the parameters for the hash function in the program
//--------------------------------------

//----------------------------------------------------------------------
// Host variables define
//----------------------------------------------------------------------
EXEC SQL BEGIN DECLARE SECTION;
struct info {
	char	*table_name;
	char	*column_name;
	char	*data_type;
	short	character_maximum_length;
	short	val_len;
}	info_schema;
EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE sqlca;
//----------------------------------------------------------------------

//--------------------------------------
// helper function forward declare
//--------------------------------------
int convertToInt(string temp); // convert string to int (atoi)
string convertToString(int temp); // convert int to string (to_string)
string attrType(string attr); // get the type of the grouping attributes
void setPrior(); // optimize the scan order for the grouping variables
void setHashPara(); // set the parameters for the hash function in the program
string convertExp(string exp, string argu); // convert the expression to C program
string convertAggregates(string agg, string argu); // add a giving prefix (argument) to every aggerate functions in the giving string (aggregate)
//--------------------------------------

//--------------------------------------
// operation function forward declare
//--------------------------------------
void readOperand(); // read and store 6 operands of phi into 6 variables including where clause
void operandProcess(); // process each varible into a better form we can operate easily
void extractTableInfo(); // get the columns that are needed for the query
bool checkTable(); // check if the table and columns exist in the schema, if not output "No such table and columns exist"
		   // instead of generate the program file
void writeProgram(); // generate the program
//--------------------------------------

int main()
{
	readOperand();
	operandProcess();
	extractTableInfo();
	bool flag=checkTable(); // flag for existance of table and columns
	if(!flag)
	{
		cout << "No such table and columns exist" << endl;
		return 1; // indicates error
	}
	setPrior();
	setHashPara();
	writeProgram();
	return 0; // indicates success
}

void readOperand()	// assigned Lingzhi Yuan
{
	string t;	// temp string to store the line
	getline(cin,t);
	if(t=="S")
	{
		getline(cin,s);
		if(s=="n") 
		{
			t=s;
			s="";
		}
		else getline(cin,t);
	}
	if(t=="n")
	{
		getline(cin,n);
		if(n=="V") 
		{
			t=n;
			n="";
		}
		else getline(cin,t);
	}
	if(t=="V")
	{
		getline(cin,v);
		if(v=="F")
		{
			t=v;
			v="";
		}
		else getline(cin,t);
	}
	if(t=="F")
	{
		getline(cin,f);
		if(f=="o")
		{
			t=f;
			f="";
		}
		else getline(cin,t);
	}
	if(t=="o")
	{
		getline(cin,o);
		while(o!="G")
		{
			vecO.push_back(o);
			getline(cin,o);
		}
		t=o;
	}
	if(t=="G")
	{
		getline(cin,g);
		if(g=="W")
		{
			t=g;
			g="";
		}
		else getline(cin,t);
	}
	if(t=="W")
	{
		getline(cin,w);
		if(w=="T")
		{
			t=w;
			w="";
		}
		else getline(cin,t);
	}
	if(t=="T")
	{
		getline(cin,tableName);
	}
}

void operandProcess() //  assigned Yanjun Wu
{
	stringstream ss;
	string temp;
	ss << s;
	while(!ss.eof())
	{
		temp="";
		ss >> temp;
		if(temp=="") continue;
		if(temp[temp.size()-1]==',') temp.erase(temp.size()-1,1);
		S.push_back(temp);
	}
	N=convertToInt(n);
	ss.clear();
	ss << v;
	while(!ss.eof())
	{
		temp="";
		ss >> temp;
		if(temp=="") continue;
		if(temp[temp.size()-1]==',') temp.erase(temp.size()-1,1);
		V.push_back(temp);
	}
	ss.clear();
	ss << f;
	while(!ss.eof())
	{
		temp="";
		ss >> temp;
		if(temp=="") continue;
		if(temp[temp.size()-1]==',') temp.erase(temp.size()-1,1);
		string tempSum, tempCount, tempAvg;
		if(temp.find("sum")!=-1) tempSum=temp;
		else if(temp.find("count")!=-1) tempCount=temp;
		else if(temp.find("avg")!=-1)	// in order to compute avg, we add sum and count into aggregate functions before the giving avg
		{
			tempAvg = temp;
			tempSum = temp.replace(temp.find("avg"),3,"sum");
			tempCount = temp.replace(temp.find("sum"),3,"count");
		}
		if(tempSum!="")
		{
			int i;
			for(i = 0; i < F.size(); i++)
			if(F[i]==tempSum) break;
			if(i==F.size()) F.push_back(tempSum);
		}
		if(tempCount!="")
		{
			int i;
			for(i = 0; i < F.size(); i++)
			if(F[i]==tempCount) break;
			if(i==F.size()) F.push_back(tempCount);
		}
		if(tempAvg!="")
		{
			F.push_back(tempAvg);
		}
	}
	VECO.resize(N);
	for(int i = 0; i < vecO.size(); i++)
	{
		temp="";
		ss.clear();
		if(vecO[i]=="") continue;
		ss << vecO[i];
		ss >> temp;
		if(temp=="") continue;
		int tempN = convertToInt(temp);
		while(!ss.eof())
		{
			temp="";
			ss >> temp;
			if(temp=="") continue;
			if(temp[temp.size()-1]==',') temp.erase(temp.size()-1,1);
			if(temp == "and") // convert logical operators from natural language to programming language
				temp = "&&";
			else if (temp == "or")
				temp = "||";
			VECO[tempN-1].push_back(temp);
		}
	}
	ss.clear();
	ss << g;
	while(!ss.eof())
	{
		temp = "";
		ss >> temp;
		if(temp=="") continue;
		if(temp[temp.size()-1]==',') temp.erase(temp.size()-1,1);
		if(temp == "and")
			temp = "&&";
		else if (temp == "or")
			temp = "||";
		G.push_back(temp);
	}
	ss.clear();
	ss << w;
	while(!ss.eof())
	{
		temp = "";
		ss >> temp;
		if(temp=="") continue;
		if(temp[temp.size()-1]==',') temp.erase(temp.size()-1,1);
		if(temp == "and")
			temp = "&&";
		else if (temp == "or")
			temp = "||";
		W.push_back(temp);
	}
}

void extractTableInfo()// assigned: Gong Cheng
{
	for(int i = 0; i < V.size(); i++) // store the grouping attributes into columns
	{
		string temp = V[i];
		if(V[i] == "mm") temp = "month";
		if(V[i] == "yy") temp = "year";
		if(V[i] == "dd") temp = "day";
		columnsName.push_back(temp);
	}
	for(int i = 0; i < F.size(); i++) // find the columns in the aggregate functions and store them if hasn't been stored
	{
		string temp = F[i].substr(F[i].find_last_of("_") + 1);
		if(temp == "mm") temp = "month";
		if(temp == "yy") temp = "year";
		if(temp == "dd") temp = "day";
		bool flag = false; // flag for existance of the columns
		for(int j = 0; j < columnsName.size(); j++)
		{
			if(columnsName[j] == temp)
			{
				flag = true;
				break;
			}
		}
		if(!flag) columnsName.push_back(temp);
	}
	for(int i = 0; i < VECO.size(); i++) // find the columns in the sigma operand and store them if hasn't been stored
	{
		for(int j = 0; j < VECO[i].size(); j++)
		{
			if(VECO[i][j] == "&&" || VECO[i][j] == "||") continue;
			int first = VECO[i][j].find_first_not_of("(");
			if(first == -1) first = 0;
			int second = VECO[i][j].find_first_of("=<>");
			string temp = VECO[i][j].substr(first, second - first);
			if(temp == "mm") temp = "month";
			if(temp == "yy") temp = "year";
			if(temp == "dd") temp = "day";
			bool flag = false; // flag for existance of the columns
			for(int k = 0; k < columnsName.size(); k++)
			{
				if(columnsName[k] == temp)
				{
					flag = true;
					break;
				}
			}
			if(!flag) columnsName.push_back(temp);
		}
	}
	for(int i = 0; i < W.size(); i++) // find the columns in the where clause and store them if hasn't been stored
	{
		if(W[i] == "&&" || W[i] == "||") continue;
		int first = W[i].find_first_of("=<>");
		string temp = W[i].substr(0, first);
		if(temp == "mm") temp = "month";
		if(temp == "yy") temp = "year";
		if(temp == "dd") temp = "day";
		bool flag = false; // flag for existance of the columns
		for(int k = 0; k < columnsName.size(); k++)
		{
			if(columnsName[k] == temp)
			{
				flag = true;
				break;
			}
		}
		if(!flag) columnsName.push_back(temp);
	}
	dataType.resize(columnsName.size()); // set the size of dataType to the same as columnsName
}

bool checkTable()// assigned: Gong Cheng
{
   //----------------------------------------------------------------------
   // DATABASE CONNECTION
   //----------------------------------------------------------------------
   EXEC SQL CONNECT TO cs562@localhost:5432 USER postgres IDENTIFIED BY cs562;
   EXEC SQL WHENEVER sqlerror sqlprint;
   //----------------------------------------------------------------------
   // READ RECORDS
   //----------------------------------------------------------------------
   EXEC SQL DECLARE mycursor CURSOR FOR select a.table_name, a.column_name, a.data_type, a.character_maximum_length
   from information_schema.columns as a, information_schema.tables as b
   where a.table_name=b.table_name and b.table_schema NOT IN ('pg_catalog', 'information_schema'); // find all the user tables
   EXEC SQL SET TRANSACTION read only;
   EXEC SQL OPEN mycursor;
   // Fetch Data
   EXEC SQL FETCH FROM mycursor INTO :info_schema.table_name, :info_schema.column_name, :info_schema.data_type, 
   :info_schema.character_maximum_length :info_schema.val_len; //fetch the first row
   int count = 0; // count for the columns that are found in the infomation schema

   while (sqlca.sqlcode == 0) {
	if(strcmp(tableName.c_str(),info_schema.table_name) == 0)
	for(int i = 0; i < columnsName.size(); i++)
	{
		if(strcmp(columnsName[i].c_str(),info_schema.column_name)==0)
		{
			count++;
			if(strcmp(info_schema.data_type, "character") == 0 || strcmp(info_schema.data_type, "character varying") == 0)
				dataType[i]=("char["+convertToString(info_schema.character_maximum_length + 1)+"]");
			else if(strcmp(info_schema.data_type, "integer") == 0)
				dataType[i]=("long");
			else if(strcmp(info_schema.data_type, "smallint") == 0)
				dataType[i]=("short");
			else // used for adding other type of data
				dataType[i]=("long");
			break;
		}
	}
	EXEC SQL FETCH FROM mycursor INTO :info_schema.table_name, :info_schema.column_name, :info_schema.data_type, 
	:info_schema.character_maximum_length :info_schema.val_len; //fetch the rest rows
   }
   EXEC SQL CLOSE mycursor; // Close cursor
   if(count<columnsName.size()) // if not all columns are found, return false
	   return false;
   else // return true if all columns are found
	   return true;
}

//--------------------------------------------------------
// function forward declare for generating program
//--------------------------------------------------------
void writeFirstPart(); 	// write instructions of operating the generated program and the struct of the table
void writeSecondPart();	// forward declare the hash function and MFS initialization function, connect to the database
void writeThirdPart();	// implement MFS initialization function
void writeMFS();	// generate the MF Struct
void writeGroupingAttr();// store the grouping attributes into hash table and initialize the aggregate functions to 0	
void writeCompleteTable(); // compute the aggregate functions by the range of each grouping variables
void writeOutput(); // generate the output part of the program in a highly readable format
void writeHashFunc(); // return hash key with the giving parameters 
void writeQsortCmp(); // write the Quick sort compare function
//--------------------------------------------------------

void writeProgram()
{
	writeFirstPart();
	writeMFS();
	writeSecondPart();
	writeGroupingAttr();//assigned: Zhe Xu
	writeCompleteTable(); //assigned: Gong Cheng
	writeOutput(); //assigned: Yanjun Wu
	writeThirdPart();
	writeHashFunc(); //assigned: Lingzhi Yuan
	writeQsortCmp(); //assigned: Gong Cheng
}

void writeFirstPart() 
{
	cout << "//--first--" << endl <<
	"/*" << endl <<
	" * File - \"program.pgc\"" << endl <<
	" * Desc - This is the program generated by our engine." << endl <<
	" * Team - SDE(Stevens Dota Elites/Software Development Engineers)." << endl <<
	" * Memb - Gong Cheng 	10390440" << endl <<
	" *	  Lingzhi Yuan	10391683" << endl <<
	" *	  Yanjun Wu	10392467" << endl <<
	" *	  Zhe Xu	10393213" << endl <<
	" *" << endl <<
	" * Steps to run this program : (Make sure you have installed postgresql and ecpg)" << endl <<
	" *  1. Log in to PostgreSQL server." << endl <<
	" *  2. In the DATABASE CONNECTION, modify [dbname], [host], [port], [username], [password] to" << endl <<
	" *     yours ([dbname] is the same as your [username] by default)." << endl <<
	" *  3. Preprocessor - $ ecpg -I /usr/include/postgresql program.pgc" << endl <<
	" *  4. Compile      - $ gcc -c -I /usr/include/postgresql/ program.c" << endl <<
	" *  5. Link         - $ gcc -L /usr/include/postgresql/ program.o -lecpg -o program" << endl <<
	" *  6. Execute      - $ ./program" << endl <<
	" */" << endl <<
	endl <<
	"//--------------------------------------" << endl <<
	"//including libraries (all standard libraries)" << endl <<
	"//--------------------------------------" << endl <<
	"#include <stdio.h>" << endl <<
	"#include <stdlib.h>" << endl <<
	"#include <string.h> // used for string comparison" << endl <<
	"//--------------------------------------" << endl <<
	endl <<
	"//----------------------------------------------------------------------" << endl <<
	"// Host variables define" << endl <<
	"//----------------------------------------------------------------------" << endl <<
	"EXEC SQL BEGIN DECLARE SECTION;" << endl <<
	"struct {" << endl; // write the host variables by the column names
	for(int i = 0; i < columnsName.size(); i++)
	{
		string temp = columnsName[i];
		if(temp == "month") temp = "mm";
		if(temp == "year") temp = "yy";
		if(temp == "day") temp = "dd";
		if(dataType[i].find("char") != -1)
			cout << "	char	*" + temp + ";" << endl;
		else
			cout << "	" << dataType[i] << "	" + temp + ";" << endl;
	}
	cout <<
	"}	sale_rec;" << endl <<
	"EXEC SQL END DECLARE SECTION;" << endl <<
	"EXEC SQL INCLUDE sqlca;" << endl <<
	"//----------------------------------------------------------------------" << endl <<
	"//--end first--" << endl << endl;
}

void writeSecondPart()
{
	cout << "//--second--" << endl <<
	"//----------------------------------------------------------------------" << endl <<
	"// FUNCTION PROTOTYPE declaration" << endl <<
	"//----------------------------------------------------------------------" << endl <<
	"void	initialMFS();" << endl <<
	"unsigned int	hashFunc(";
	if(hashPara.size() != 0)	// assign parameters to hash function
	{
		for(int i = 0; i < hashPara.size() - 1; i++)
		{
			string type = attrType(hashPara[i]);
			if(type.find("char") != -1) cout << "char*, ";
			else cout << type << ", ";
		}
		string type = attrType(hashPara[hashPara.size() - 1]);
		if(type.find("char") != -1) cout << "char*";
		else cout << type;
	}
	cout << ");" << endl <<
	"int compare(const void *p1, const void *p2);" << endl <<
	"//----------------------------------------------------------------------" << endl << endl <<
	"int main(int argc, char* argv[])" << endl <<
	"//----------------------------------------------------------------------" << endl <<
	"{" << endl <<
	"   int i;" << endl <<
	"   initialMFS();" << endl <<
	"   //----------------------------------------------------------------------" << endl <<
	"   // DATABASE CONNECTION" << endl <<
	"   //----------------------------------------------------------------------" << endl <<
	"   EXEC SQL CONNECT TO cs562@localhost:5432 USER postgres IDENTIFIED BY cs562;" << endl <<
	"   EXEC SQL WHENEVER sqlerror sqlprint;" << endl <<
	"   //----------------------------------------------------------------------" << endl <<
	"   // READ RECORDS" << endl <<
	"   //----------------------------------------------------------------------" << endl <<
	"   EXEC SQL DECLARE mycursor CURSOR FOR SELECT ";
	for(int i = 0; i < columnsName.size() - 1; i++) 
	{
		cout << columnsName[i] << ", ";
	}
	cout << columnsName[columnsName.size() - 1] << " FROM " << tableName + ";" << endl <<
	"   EXEC SQL SET TRANSACTION read only;" << endl <<
	"//--end second--" << endl << endl;
}

void writeThirdPart()
{
	cout << "//--third--" << endl <<
	"   return 0;" << endl <<
	"}" << endl << endl <<	
	"//--------------------------------------" << endl <<
	"// MFS initialization" << endl <<
	"//--------------------------------------" << endl <<
	"void	initialMFS()" << endl <<
	"{" << endl <<
	"	int i;" << endl <<
	"	for(i = 0; i < 500; i++)" << endl <<
	"	{" << endl <<
	"		MFS[i].flag=0; // set all flags to false" << endl <<
	"	}" << endl <<
	"}" << endl <<
	endl<<"//--end third--"<<endl;
}

void writeMFS() // assigned Zhe Xu
{
	cout <<
	"//----------------------------------------------------------------------" << endl <<
	"// MF Struct define" << endl <<
	"//----------------------------------------------------------------------" << endl <<
	"struct m{" << endl <<
	"	bool flag;" << endl;
	for(int i = 0; i < V.size(); i++)	// store grouping attributes into MFS
	{
		string type = attrType(V[i]);
		if(type.find("char")!=-1)
			cout << "	char " << V[i] << type.substr(4) << ";" << endl;
		else
			cout << "	" <<type << " " << V[i] << ";" << endl;
	}
	for(int i = 0; i < F.size(); i++)	// store aggregate functions into MFS
	{
		if(F[i].find("count") == -1) cout << "	long " << F[i] << ";" << endl;
		else cout << "	short " << F[i] << ";" << endl;
	}
	cout << "} MFS[500];" << endl << 
	"//----------------------------------------------------------------------" << endl <<endl;
}


void writeGroupingAttr()//assigned: Zhe Xu
{
	cout <<
	"   // group by grouping attributes,  assigned: Zhe Xu" << endl <<
	"   // Open cursor" << endl <<
	"   EXEC SQL OPEN mycursor;" << endl <<
	"   // Fetch Data" << endl <<
	"   EXEC SQL FETCH FROM mycursor INTO :sale_rec; //fetch the first row" << endl <<
	"   while (sqlca.sqlcode == 0) {" << endl;
	if(W.size() != 0)  // where clause condition
	{
		cout <<"    if(";
		for(int i = 0; i < W.size(); i++)
		{
			cout << convertExp(W[i], "sale_rec") << " ";
		}
		cout << ") // condition for where clause" << endl <<
		"    {" << endl;
	}
	cout <<
	"	unsigned int hash = hashFunc(";
	if(hashPara.size() != 0) // assign parameters to hash function
	{
		for(int i = 0; i < hashPara.size() - 1; i++)
		cout << "sale_rec." << hashPara[i] << ", ";
		cout << "sale_rec." << hashPara[hashPara.size() - 1];
	}
	cout << "); // get the hash key" << endl <<
	"	while(MFS[hash].flag!=false) // solve the collision by using linear probing" << endl <<
	"	{" << endl;
	cout <<"		if(";
	for(int i = 0; i < V.size() - 1; i++) // check if the grouping attributes exist in MFS
	{
		if(attrType(V[i]).find("char") != -1)
		cout << "strcmp(sale_rec." + V[i] + ", MFS[hash]." + V[i] + ") == 0 && ";
		else cout << "sale_rec." + V[i] + " == MFS[hash]." + V[i] + " && ";
	}
	if(attrType(V[V.size() - 1]).find("char") != -1)
	cout << "strcmp(sale_rec." + V[V.size() - 1] + ", MFS[hash]." + V[V.size() - 1] + ") == 0";
	else cout << "sale_rec." + V[V.size() - 1] + " == MFS[hash]." + V[V.size() - 1];

	cout << ") break;" << endl <<
	"		else hash=(hash + 1) % 500;" << endl;
	cout <<
	"	}" << endl <<
	"	if(MFS[hash].flag==false) // if the grouping attributes not exist, insert into table" << endl <<
	"	{" << endl;
	for(int i = 0; i < V.size(); i++) // insert the grouping attributes if not exist
	{
		if(attrType(V[i]).find("char") != -1)
		{
			cout << "		for(i = 0; sale_rec." + V[i] + "[i]!='\\0'; i++)" << endl <<
			"			MFS[hash]." + V[i] + "[i] = sale_rec." + V[i] + "[i];" << endl <<
			"		MFS[hash]." + V[i] + "[i] = '\\0';" << endl;
		}
		else cout << "		MFS[hash]." + V[i] + " = sale_rec." << V[i] << ";" << endl;
	}
	for(int i = 0; i < F.size(); i++) // initialize the value of aggregate functions to 0
	{
		cout << "		MFS[hash]." + F[i] + " = 0;" << endl;
	}
	cout << "		MFS[hash].flag = 1;" << endl <<
	"	}" << endl;
	if(W.size() != 0) cout << "    }" << endl;
	cout <<
	"      EXEC SQL FETCH FROM mycursor INTO :sale_rec; //fetch the rest rows" << endl <<
	"   }" << endl <<
	"   // Close cursor" << endl <<
	"   EXEC SQL CLOSE mycursor;" << endl <<
	"   //----------------------------------------------------------------------" << endl;
}

void writeCompleteTable() //assigned: Gong Cheng
{
	cout << 
	"   //optimization for independent grouping attributes  assigned: Gong Cheng" << endl;

	for(int p = 0; p < aggrPrior.size(); p++) // compute the aggregate functions for all independent g.v.(including g.v. 0) per scan
	{
		cout << "   //Scan " << p + 1 << endl <<
		"   // Open cursor" << endl <<
		"   EXEC SQL OPEN mycursor;" << endl <<
		"   // Fetch Data" << endl <<
		"   EXEC SQL FETCH FROM mycursor INTO :sale_rec; //fetch the first row" << endl <<
		"   while (sqlca.sqlcode == 0) {" << endl;
		if(W.size() != 0)  // where clause condition
		{
			cout <<"    if(";
			for(int i = 0; i < W.size(); i++)
			{
				cout << convertExp(W[i], "sale_rec") << " ";
			}
			cout << ") // condition for where clause" << endl <<
			"    {" << endl;
		}

		cout <<
		"	unsigned int hash = hashFunc(";
		if(hashPara.size() != 0) // assign parameters to hash function
		{
			for(int i = 0; i < hashPara.size() - 1; i++)
			cout << "sale_rec." << hashPara[i] << ", ";
			cout << "sale_rec." << hashPara[hashPara.size() - 1];
		}
		cout << "); // get the hash key" << endl <<
		"	unsigned int hashScan;" << endl;
		vector<int> MFvar, EMFvar; // MF 1 to 1, EMF 1 to n
		bool globalVal = false; // flag for g.v. 0
		for(int q = 0; q < aggrPrior[p].size(); q++) // split the MF variables and EMF variables
		{
			if(aggrPrior[p][q] == 0) 
			{
				globalVal = true; 
				continue;
			}
			bool MFflag = true; // flag for the MF/EMF variable
			int varNum = aggrPrior[p][q]; 
			for(int i = 0; i < V.size(); i++)
			{
				bool findV = false; // flag for the existance of the grouping attribute
				for(int j = 0; j < VECO[varNum - 1].size(); j++)
				{
					if(VECO[varNum - 1][j] == V[i] + "=" + V[i])
					{
						findV = true; 
						break;
					}
				}
				if(!findV) 
				{
					MFflag = false;
					break;
				}
			}
			if(MFflag) MFvar.push_back(varNum);
			else EMFvar.push_back(varNum);
		}
		if(globalVal) // process for g.v. 0 aggregate functions
		{
			cout <<
			"	for(i = 0; i < 500; i++) // compute the aggregate functions for g.v. 0" << endl <<
			"	{" << endl <<
			"		if(MFS[i].flag == 0) continue;" << endl <<
			"		if(";
			for(int i = 0; i < V.size() - 1; i++) // check the condition for the grouping attributes
			{
				if(attrType(V[i]).find("char") != -1)
				cout << "strcmp(sale_rec." + V[i] + ", MFS[i]." + V[i] + ") == 0 && ";
				else cout << "sale_rec." + V[i] + " == MFS[i]." + V[i] + " && ";
			}
			if(attrType(V[V.size() - 1]).find("char") != -1)
			cout << "strcmp(sale_rec." + V[V.size() - 1] + ", MFS[i]." + V[V.size() - 1] + ") == 0";
			else cout << "sale_rec." + V[V.size() - 1] + " == MFS[i]." + V[V.size() - 1];
			cout << ") // only update the relative entries" << endl <<
			"		{" << endl;
			for(int i = 0; i < F.size(); i++) // update the aggregate functions for g.v. 0
			{
				string stringVar = "_0_";
				if(F[i].find(stringVar) != -1)
				{
					if(F[i].find("sum") != -1)
					{
						string attr = F[i].substr(F[i].find_last_of('_') + 1);
						cout << "			" << 
						convertAggregates(F[i], "MFS[i]") << "+= sale_rec." << attr << ";" << endl;
					}
					else if(F[i].find("count") != -1)
					{
						cout << "			" << convertAggregates(F[i], "MFS[i]") << "++ ;" << endl;
					}
					else if(F[i].find("avg") != -1)
					{
						string tempSum = F[i], tempCount = F[i];
						tempSum.replace(tempSum.find("avg"), 3, "sum");
						tempCount.replace(tempCount.find("avg"), 3, "count");
						cout << "			" << convertAggregates(F[i], "MFS[i]") << 
						" = MFS[i]." << tempSum << " / MFS[i]." << tempCount << ";" << endl;
					}
				}
			}
			cout << "		}" << endl <<
			"	}" << endl;
		}

		if(MFvar.size() != 0) // process for MF variable
		{
			cout <<
			"	hashScan = hash;" << endl <<
			"	while(";
			for(int i = 0; i < V.size() - 1; i++) // find the exact row
			{
				if(i) cout << "	      ";
				if(attrType(V[i]).find("char") != -1)
				cout << "strcmp(MFS[hashScan]." << V[i] << ", sale_rec." << V[i] << ") != 0 || " << endl;
				else cout << "MFS[hashScan]." << V[i] << " != sale_rec." << V[i] << " || " << endl;
			}
			if(V.size() > 1) cout << "	      ";
			if(attrType(V[V.size() - 1]).find("char") != -1)
			cout << "strcmp(MFS[hashScan]." << V[V.size() - 1] << ", sale_rec." << V[V.size() - 1] << ") != 0)" << endl;
			else cout << "MFS[hashScan]." << V[V.size() - 1] << " != sale_rec." << V[V.size() - 1] << 
			") // find the exact entry for the MF variable" << endl;
			cout <<
			"	{" << endl <<
			"		hashScan=(hashScan + 1) % 500;" << endl <<
			"	}" << endl;
		}
		for(int q = 0; q < MFvar.size(); q++) // process for MF variable
		{
			cout << "	if(";
			if(VECO[MFvar[q] - 1].size() > (V.size() * 2 - 1)) // check the condition for the MF variable
			{
				for(int i = 0; i < VECO[MFvar[q] - 1].size(); i++)
				{
					bool GAflag = false; // flag for grouping attributes
					if(VECO[MFvar[q] - 1][i].find("&&") == -1 && VECO[MFvar[q] - 1][i].find("||") == -1)
					for(int j = 0; j < V.size(); j++)
					{
						if(VECO[MFvar[q] - 1][i] == V[j] + "=" + V[j])
						{
							GAflag = true; 
							break;
						}
					}
					if(GAflag)
					{
						i++;
					}
					else
					{
						string judgeExp = convertExp(VECO[MFvar[q] - 1][i], "MFS[hashScan]");
						string findExp = judgeExp;
						for(int j = 0; j < F.size(); j++) // check if count==0 when counting avg
						{
							if(F[j].find("avg") == -1) continue;
							if(findExp.find(F[j]) != -1)
							{
								string tempF = F[j];
								tempF.replace(0, 3 , "MFS[hashScan].count");
								tempF += " != 0 && ";
								judgeExp.replace(judgeExp.find_first_not_of('('), 0, tempF);
							}
						}
						cout << judgeExp << " ";
					}
				}
			}
			else cout << "1";
			cout << ") // update the entry if conditions match" << endl << 
			"	{" << endl;
			for(int i = 0; i < F.size(); i++) // compute the aggregate functions for the MF variable
			{
				string stringVar = "_" + convertToString(MFvar[q]) + "_";
				if(F[i].find(stringVar) != -1)
				{
					if(F[i].find("sum") != -1)
					{
						string attr = F[i].substr(F[i].find_last_of('_') + 1);
						cout << "		" << 
						convertAggregates(F[i], "MFS[hashScan]") << "+= sale_rec." << attr << ";" << endl;
					}
					else if(F[i].find("count") != -1)
					{
						cout << "		" << convertAggregates(F[i], "MFS[hashScan]") << "++;" << endl;
					}
					else if(F[i].find("avg") != -1)
					{
						string tempSum = F[i], tempCount = F[i];
						tempSum.replace(tempSum.find("avg"), 3, "sum");
						tempCount.replace(tempCount.find("avg"), 3, "count");
						cout << "		" << convertAggregates(F[i], "MFS[hashScan]") << 
						" = MFS[hashScan]." << tempSum << " / MFS[hashScan]." << tempCount << ";" << endl;
					}
				}
			}
			cout << "	}" << endl;
		}
		if(EMFvar.size() != 0) // process for EMF variable
		{
			cout <<
			"	hashScan = hash;" << endl <<
			"	for(i = 0; i < 500; i++) // find all the relative entries" << endl <<
			"	{" << endl <<
			"		if(MFS[hashScan].flag == 0) break;" << endl;
			for(int q = 0; q < EMFvar.size(); q++) // process for EMF variable
			{
				cout << "		if(";
				for(int i = 0; i < VECO[EMFvar[q] - 1].size(); i++)
				{
					if(i && (VECO[EMFvar[q] - 1][i] != "&&" && VECO[EMFvar[q] - 1][i] != "||")) cout << "		   ";
					string judgeExp = convertExp(VECO[EMFvar[q] - 1][i], "MFS[hashScan]");
					string findExp = judgeExp;
					for(int j = 0; j < F.size(); j++) // check if count==0 when counting avg
					{
						if(F[j].find("avg") == -1) continue;
						if(findExp.find(F[j]) != -1)
						{
							string tempF = F[j];
							tempF.replace(0, 3 , "MFS[hashScan].count");
							tempF += " != 0 && ";
							judgeExp.replace(judgeExp.find_first_not_of('('), 0, tempF);
						}
					}
					cout << judgeExp << " ";
					if(i < VECO[EMFvar[q] - 1].size() - 1 && 
					(VECO[EMFvar[q] - 1][i] == "&&" || VECO[EMFvar[q] - 1][i] == "||")) cout << endl;
				}
				cout << ") // update the entry if conditions match" << endl <<
				"		{" << endl;
				for(int i = 0; i < F.size(); i++) // compute the aggregate functions for the MF variable
				{
					string stringVar = "_" + convertToString(EMFvar[q]) + "_";
					if(F[i].find(stringVar) != -1)
					{
						if(F[i].find("sum") != -1)
						{
							string attr = F[i].substr(F[i].find_last_of('_') + 1);
							cout << "			" << 
							convertAggregates(F[i], "MFS[hashScan]") << "+= sale_rec." << attr << ";" << endl;
						}
						else if(F[i].find("count") != -1)
						{
							cout << "			" << 
							convertAggregates(F[i], "MFS[hashScan]") << "++;" << endl;
						}
						else if(F[i].find("avg") != -1)
						{
							string tempSum = F[i], tempCount = F[i];
							tempSum.replace(tempSum.find("avg"), 3, "sum");
							tempCount.replace(tempCount.find("avg"), 3, "count");
							cout << "			" << convertAggregates(F[i], "MFS[hashScan]") << 
							" = MFS[hashScan]." << tempSum << " / MFS[hashScan]." << tempCount << ";" << endl;
						}
					}

				}
				cout << "		}" << endl;
			}
			cout <<
			"		hashScan=(hashScan + 1) % 500;" << endl <<
			"	}" << endl;
		}


		if(W.size() != 0) cout << "    }" << endl;
		cout <<
	 	"     EXEC SQL FETCH FROM mycursor INTO :sale_rec; //fetch the rest rows" << endl <<
		"   }" << endl <<
		"   // Close cursor" << endl <<
		"   EXEC SQL CLOSE mycursor;" << endl <<
		"   //----------------------------------------------------------------------" << endl <<
		endl;
	}
}

void writeOutput() //assigned: Yanjun Wu
{	string title = "";
	string subTitle = "";
	string temp = "";
	for (int i = 0; i < S.size(); i++)
	{
		temp = S[i];
		transform(temp.begin(), temp.end(), temp.begin(), ::toupper); // convert lower case to upper case
		if(attrType(S[i]).find("char") != -1 && convertToInt(attrType(S[i]).substr(5, attrType(S[i]).length() - 6)) > 4)
		{
			title += " " + temp;
			for(int j = 0; j < 8 - temp.length(); j++)
				title += " ";
			title += "|";
			subTitle += "---------+";
		}
		else if(attrType(S[i]).find("char") != -1)
		{
			title += " " + temp + " |";
			for(int j = 0; j < temp.length() + 2; j++)
				subTitle += "-";
			subTitle += "+";
		}
		else
		{
			if(temp == "MM") temp = "MON";
			if(temp == "DD") temp = "DAY";
			if(temp == "YY") temp = "YEAR";
			title += " " + temp + " |";
			for(int j = 0;j < temp.length() + 2; j++)
				subTitle += "-";
			subTitle += "+";
		}
	}
	title.replace(title.length() - 1, 1, "\\n"); // replace the last character to \n
	subTitle.replace(subTitle.length() - 1, 1, "\\n");
	cout << 
	"	qsort(MFS, 500, sizeof(MFS[0]),compare); // sort the result for clear comparison" << endl <<
	"	//----------------------------------------------------------------------" << endl <<
	"	// PRINT TITLE" << endl <<
	"	//----------------------------------------------------------------------" << endl <<
	"	printf(\"" << title << "\");" << endl <<
 	"	printf(\"" << subTitle << "\");" << endl <<
	"	for(i = 0; i < 500; i++)" << endl <<
	"	{" << endl <<
	"		if(MFS[i].flag==0) break; // break when flag=false, because MFS are sorted" << endl;  
	string whiteSpace = "";
	if(G.size() > 0) // restrict the result with verifying the having clause
	{
		whiteSpace = "	";
		cout << "		if(";
		for(int i = 0; i < G.size(); i++)
		cout << convertAggregates(G[i], "MFS[i]") << " ";
		cout << ") // output the result if conditions match" << endl << "		{" << endl;
	}
	for(int i = 0; i < S.size() - 1; i++) // output all the needed attributes except the last one
	{
		cout <<
		whiteSpace << "		printf(\" ";
		if(attrType(S[i]).find("char") != -1 && convertToInt(attrType(S[i]).substr(5, attrType(S[i]).length() - 6)) > 4)
			cout << "%-7s |\", MFS[i]." << S[i] << ");" << endl;
		else if(attrType(S[i]).find("char") != -1)
			cout << "%-" << S[i].length() << "s |\", MFS[i]." << S[i] << ");" << endl;
		else if(attrType(S[i]).find("sum") == -1 && attrType(S[i]).find("avg") == -1 && attrType(S[i]).find("count") == -1)
		{
			cout << "%" << S[i].length() << "ld |\", " << "MFS[i]." + S[i] <<  ");" << endl;
		}
		else if(S[i].find("sum") != -1 || S[i].find("avg") != -1) 
			cout << "%" << S[i].length() << "ld |\", " << convertAggregates(S[i], "MFS[i]") <<  ");" << endl;
		else if(S[i].find("count") != -1)
			cout << "%" << S[i].length() << "d |\", " << convertAggregates(S[i], "MFS[i]") <<  ");" << endl;
		else if(S[i]=="mm" || S[i]=="yy" || S[i]=="dd")
		{
			if(S[i] == "dd") cout << " %2ld |\", MFS[i].dd" << ");" << endl;
			else if(S[i] == "mm") cout << " %2ld |\", MFS[i].mm" << ");" << endl;
			else if(S[i] == "yy") cout << "%4ld |\", MFS[i].yy" << ");" << endl;
		}
		else if(attrType(S[i]).find("long") != -1)
			cout << "%" << S[i].length() << "ld |\", " << convertAggregates(S[i], "MFS[i]") <<  ");" << endl;
		else
			cout << "%" << S[i].length() << "d |\", " << convertAggregates(S[i], "MFS[i]") <<  ");" << endl;
	}
	if(S.size() > 0) // output the last giving attribute
	{
		int i = S.size() - 1;
		cout <<
		whiteSpace << "		printf(\" ";
		if(attrType(S[i]).find("char") != -1 && convertToInt(attrType(S[i]).substr(5, attrType(S[i]).length() - 6)) > 4)
			cout << "%-7s |\", MFS[i]." << S[i] << ");" << endl;
		else if(attrType(S[i]).find("char") != -1)
			cout << "%-" << S[i].length() << "s \\n\", MFS[i]." << S[i] << ");" << endl;
		else if(S[i].find("sum") == -1 && S[i].find("avg") == -1 && S[i].find("count") == -1)
		{
			cout << "%" << S[i].length() << "ld \\n\", " << "MFS[i]." + S[i] <<  ");" << endl;
		}
		else if(S[i].find("sum") != -1 || S[i].find("avg") != -1) 
			cout << "%" << S[i].length() << "ld \\n\", " << convertAggregates(S[i], "MFS[i]") <<  ");" << endl;
		else if(S[i].find("count") != -1)
			cout << "%" << S[i].length() << "d \\n\", " << convertAggregates(S[i], "MFS[i]") <<  ");" << endl;
		else if(S[i]=="mm" || S[i]=="yy" || S[i]=="dd")
		{
			if(S[i] == "dd") cout << " %2ld \\n\", MFS[i].dd" << ");" << endl;
			else if(S[i] == "mm") cout << " %2ld \\n\", MFS[i].mm" << ");" << endl;
			else if(S[i] == "yy") cout << "%4ld \\n\", MFS[i].yy" << ");" << endl;
		}
		else if(attrType(S[i]).find("long") != -1)
			cout << "%" << S[i].length() << "ld \\n\", " << convertAggregates(S[i], "MFS[i]") <<  ");" << endl;
		else
			cout << "%" << S[i].length() << "d \\n\", " << convertAggregates(S[i], "MFS[i]") <<  ");" << endl;
	}
	if(G.size() > 0) cout << "		}" << endl;
	cout << "	}" << endl;
}

void writeHashFunc() //assigned: Lingzhi Yuan            //this function aimed at generating the hashfunction in pgc file
{
	cout <<
	"  //assigned: Lingzhi Yuan" << endl <<
	"//--------------------------------------" << endl <<
	"// Hash function which generate the hash key for the giving parameters" << endl <<
	"//--------------------------------------" << endl <<
	"unsigned int	hashFunc(";
	if(hashPara.size() != 0)                       //traverse the hashPara and output them as char* or long
	{
		for(int i = 0; i < hashPara.size() - 1; i++)
		{
			string type = attrType(hashPara[i]);
			if(type.find("char") != -1) cout << "char* " << hashPara[i] << ", ";
			else cout << type << " " <<  hashPara[i]  << ", ";
		}
		string type = attrType(hashPara[hashPara.size() - 1]);
		if(type.find("char") != -1) cout << "char* " << hashPara[hashPara.size() - 1];        //last one is different because last parameter 													      //should use ')' instead of ',' 
		else cout << type << " " << hashPara[hashPara.size() - 1];
	}
	cout << ")" << endl <<
	"{" << endl;
	if(hashPara.size() == 0)									//if no hashPara, just return 0
	{
		cout << "	return 0;" << endl << "}";
		return;
	}
	cout <<
	"	int i;" << endl <<									//output the necessary variables
	"	unsigned int hash = 0;" << endl <<                                                      //hashcode
	"	char temp[50]; // used for converting int to string" << endl;                           //used to record the numbers as string
	for(int i = 0; i < hashPara.size(); i++)							//this is the key algorithm for get hashcode
	{
		if(attrType(hashPara[i]).find("char") != -1)						//if it's string, parse each char of it.
		{
			cout <<
			"	for(i = 0; " << hashPara[i] << "[i]!='\\0'; i++) // hash function for strings" << endl <<
			"	{" << endl <<
			"		hash = (hash<<4)^(hash>>28)^" << hashPara[i] << "[i];" << endl <<
			"	}" << endl;
		}
		else if(attrType(hashPara[i]).find("long") != -1)              				//if it's a number,transfer it into string,  
													//and do the same like above.
		{
			cout <<
			"	for(i = 0; i < 50; i++) temp[i] = '0'; // initializing temp" << endl <<
			"	temp[49] = '\\0';" << endl <<
			"	sprintf (temp, \"%ld\" , " << hashPara[i] << 				//long int
			"); // convert int to string" << endl <<            
			"	for(i = 0; temp[i]!='\\0'; i++) // hash function for strings" << endl <<
			"	{" << endl <<
			"		hash = (hash<<4)^(hash>>28)^temp[i];" << endl <<
			"	}" << endl;
			
		}
		else
		{
			cout <<
			"	for(i = 0; i < 50; i++) temp[i] = '0'; // initializing temp" << endl <<
			"	temp[49] = '\\0';" << endl <<
			"	sprintf (temp, \"%d\" , " << hashPara[i] << ");" << endl <<		//short
			"); // convert int to string" << endl <<            
			"	for(i = 0; temp[i]!='\\0'; i++) // hash function for strings" << endl <<
			"	{" << endl <<
			"		hash = (hash<<4)^(hash>>28)^temp[i];" << endl <<
			"	}" << endl;
		}
			
	}
	cout <<
	"	return (hash%500);" << endl <<								//return the hash key.
	"}" << endl;
}

void writeQsortCmp()
{
	cout <<
	"int compare(const void *p1, const void *p2) // compare function for MFS quick sort" << endl <<
	"{" << endl <<
	"	const struct m *p = p1;" << endl <<
	"	const struct m *q = p2;" << endl <<
	"	if(!p->flag) return 1;" << endl <<
	"	if(!q->flag) return -1;" << endl <<
	"// Compare the columns one by one" << endl;
	for(int i = 0; i < S.size(); i++)
	{
		if(attrType(S[i]).find("char") != -1)
			cout <<
			"	if(strcmp(p->" << S[i] << ", q->" << S[i] << ") != 0) return strcmp(p->" << 
			S[i] << ", q->" << S[i] << ");" << endl;
		else
		{
			string p = convertAggregates(S[i], "p->");
			while(p.find(".") != -1)
				p.erase(p.find("."), 1);
			string q = convertAggregates(S[i], "q->");
			while(q.find(".") != -1)
				q.erase(q.find("."), 1);
			if(p.find("p->") != -1)
			cout <<
			"	if(" << p << " != " << q << ") return " << p << ">" << q << "? 1 : -1;" << endl;
			else
			cout <<
			"	if(p->" << S[i] << " != q->" << S[i] << ") return p->" << 
			S[i] << ">q->" << S[i] << "? 1 : -1;" << endl;
		}
	}
	cout << "	return 0; // if all equal, return 0" << endl <<
	"}" << endl <<
	endl;
}

int convertToInt(string temp)
{
	int tempN = 0;
	for(int i = 0; i < temp.length(); i++)
	{
		if(i!=0) tempN *= 10;
		else tempN = 0;
		tempN += temp[i]-48;
	}
	return tempN;
}

string convertToString(int temp)
{
	string tempS;
	stringstream ss;
	ss << temp;
	ss >> tempS;
	return tempS;
}

string attrType(string attr) 
{
	if(attr == "mm") attr = "month";
	if(attr == "yy") attr = "year";
	if(attr == "dd") attr = "day";
	for(int i = 0; i < columnsName.size(); i++)
	{
		if(attr == columnsName[i]) return dataType[i];
	}
	return "NULL";
}

void setPrior() // assigned Zhe Xu
{
	vector<int> init;
	bool globalValFlag = false;
	for(int i = 0; i < F.size(); i++)
	{
		if(F[i].find("_0_") != -1)
		{
			globalValFlag = true; 
			break;
		}
	}
	if(globalValFlag)
	init.push_back(0);
	int count = 0;
	while(count < N)
	{
		for(int i = 0; i < VECO.size(); i++) // try to find all the variables that have the same counting priority
		{
			bool existFlag = false; // the existing flag
			for(int p = 0; p < aggrPrior.size(); p++) // if the variable's priority is set, continue
			{
				for(int q = 0; q < aggrPrior[p].size(); q++)
				{
					if(aggrPrior[p][q] == i + 1)
					{
						existFlag = true; 
						break;
					}
				}
				if(existFlag) break;
			}
			if(existFlag) continue;
			int j = 0;
			for(; j < VECO[i].size(); j++) // try to find if there is any other variable should be counted first while not counted yet
			{
				int first = 0, second = 0;
				bool counted_prio_flag = true; // the flag for the priority, if there is any other higher 
								//priority variable that is not counted, flag = false
				while(VECO[i][j].find("_", second + 1) != -1) // find the high priority variables
				{
					counted_prio_flag = false;
					first = VECO[i][j].find("_", second + 1);
					second = VECO[i][j].find("_", first + 1);
					int prevScanNum = convertToInt(VECO[i][j].substr(first + 1, second - first - 1)); // 
					for(int p = 0; p < aggrPrior.size(); p++) // check if it is counted
					{
						for(int q = 0; q < aggrPrior[p].size(); q++)
						{
							if(aggrPrior[p][q] == prevScanNum)
							{
								counted_prio_flag = true; 
								break; // if it is counted, flag = true
							}
						}
						if(counted_prio_flag) break; // if it is counted, flag = true
					}
					if(!counted_prio_flag) break;
				}
				if(!counted_prio_flag) break; // if it is not counted, break the whole loop, j should < VECO[i].size()
			}
			if(j == VECO[i].size()) // if there is no other variable should be counted first, set the priority
			{
				count++;
				init.push_back(i + 1);
			}
		}
		aggrPrior.push_back(init); // push back the set of variables that have the same priority
		init.clear();
	}
}

void setHashPara() // assigned Lingzhi Yuan
{
	if(VECO.size() == 0) return;
	for(int i = 0; i < V.size(); i++)                       //fetch each element in v, and process it :
	{
		string tempS = "="+V[i];
		bool flag1 = true; // flag for the hash parameter
		for(int p = 0; p < VECO.size(); p++)           //traverse each row of veco
		{
			bool flag2 = false; // flag for the existance of the grouping attribute in the range of the grouping variable
			for(int q = 0; q < VECO[p].size(); q++)
			{	
				if(VECO[p][q].find(tempS) != -1 && (VECO[p][q].find(tempS) + tempS.length()) == VECO[p][q].length())
				{
					flag2 = true; 
					break;
				}
			}
			if(!flag2)
			{
				flag1 = false; 
				break;
			}
		}
		if(flag1) hashPara.push_back(V[i]); // if true, it should be one of the hash parameter
	}
}

string convertExp(string exp, string argu) // assigned Gong Cheng
{
	if(exp == "&&" || exp == "||") return exp;
	int first = exp.find_first_not_of('(');
	int second = exp.find_first_of("=<>");
	int third = exp.find_last_not_of(')');
	string parenLeft, parenRight;
	for(int i = 0; i < first; i++) parenLeft += "(";
	for(int i = third + 1; i < exp.length(); i++) parenRight += ")";

	string attribute = exp.substr(first, second - first);
	if(attribute == "cust" || attribute == "prod" || attribute == "state")
	{
		attribute = "sale_rec." + attribute;
		if(exp.find("='") != -1)
		{
			string value = exp.substr(exp.find("=") + 1, third - exp.find("="));
			value[0]='\"'; value[third - exp.find("=") - 1] = '\"';
			string convert;
			return parenLeft + "strcmp(" + attribute + ", " + value + ") == 0" + parenRight;
		}
		else if(exp.find("<>'") != -1)
		{
			string value = exp.substr(exp.find("<>") + 2, third - exp.find("<>") - 1);
			value[0]='\"'; value[third - exp.find("<>") - 2] = '\"';
			return parenLeft + "strcmp(" + attribute + ", " + value + ") != 0" + parenRight;
		}
		else if(exp.find("=") != -1)
		{
			string value = argu + "." + exp.substr(exp.find("=") + 1, third - exp.find("="));
			return parenLeft + "strcmp(" + attribute + ", " + value + ") == 0" + parenRight;
		}
		else if(exp.find("<>") != -1)
		{
			string value = argu + "." + exp.substr(exp.find("<>") + 2, third - exp.find("<>") - 1);
			return parenLeft + "strcmp(" + attribute + ", " + value + ") != 0" + parenRight;
		}
	}
	else
	{
		if(exp.find(attribute, second) != -1)
		{
			int valueStart = exp.find_first_not_of("=<>", second);
			string value = exp.substr(valueStart);
			value = argu + "." + value;
			attribute = "sale_rec." + attribute;
			string rtnExp = parenLeft + attribute + exp.substr(second, valueStart - second) + value;
			first = 0;
			if(rtnExp.find("=", first) != -1 && rtnExp.find(">", first) == -1 && rtnExp.find("<", first) == -1)
			{
				first = rtnExp.find("=", first);
				rtnExp.replace(first, 1, "==");
			}
			first = 0;
			if(rtnExp.find("<>", first) != -1)
			{
				first = rtnExp.find("<>", first);
				rtnExp.replace(first, 2, "!=");
			}
			return rtnExp; 
		}
		else
		{
			attribute = "sale_rec." + attribute;
			string value = convertAggregates(exp.substr(second), argu);
			return parenLeft + attribute + value; 
		}
	}
}
string convertAggregates(string agg, string argu) // assigned Yanjun
{
	int first = 0, second = 0;
	if(agg.find_first_of("()+-*/=<>", second) != 0) // check if all the operators are not the first character
	{
		if(agg.find_first_of("()+-*/=<>", second) != -1) // check if any of the operators exist
		{
			second = agg.find_first_of("()+-*/=<>", second); 
			string tempA = agg.substr(first, second - first - 1); // tempA extract the first aggregate function
			if(tempA.find("sum") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("sum"), 3, argu + ".sum");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length(); // reassign "second"
			}
			else if(tempA.find("count") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("count"), 5, argu + ".count");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length();
			}
			else if(tempA.find("avg") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("avg"), 3, argu + ".avg");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length();
			}
		}
		else // process the last aggregate function
		{
			second = agg.length();
			string tempA = agg.substr(first, second - first);
			if(tempA.find("sum") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("sum"), 3, argu + ".sum");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length();
			}
			else if(tempA.find("count") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("count"), 5, argu + ".count");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length();
			}
			else if(tempA.find("avg") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("avg"), 3, argu + ".avg");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length();
			}
		}
	}
	while(agg.find_first_of("()+-*/=<>", second) != -1) // process the rest of aggregate functions if the first character is those operators
							    // stated before
	{
		first = agg.find_first_of("()+-*/=<>", second);
		second = agg.find_first_of("()+-*/=<>", first + 1);
		if(second == -1)
		{
			second = agg.length();
			string tempA = agg.substr(first, second - first);
			if(tempA.find("sum") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("sum"), 3, argu + ".sum");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length() + 3;
			}
			else if(tempA.find("count") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("count"), 5, argu + ".count");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length() + 5;
			}
			else if(tempA.find("avg") != -1)
			{
				string tempB = tempA;
				tempB.replace(tempB.find("avg"), 3, argu + ".avg");
				agg.replace(agg.find(tempA), tempA.length(), tempB);
				second += tempB.length() - tempA.length() + 3;
			}
			break;
		}
		if(second - first == 1) continue;
		string tempA = agg.substr(first + 1, second - first - 1);
		if(tempA.find("sum") != -1)
		{
			string tempB = tempA;
			tempB.replace(tempB.find("sum"), 3, argu + ".sum");
			agg.replace(agg.find(tempA), tempA.length(), tempB);
			second += tempB.length() - tempA.length();
		}
		else if(tempA.find("count") != -1)
		{
			string tempB = tempA;
			tempB.replace(tempB.find("count"), 5, argu + ".count");
			agg.replace(agg.find(tempA), tempA.length(), tempB);
			second += tempB.length() - tempA.length();
		}
		else if(tempA.find("avg") != -1)
		{
			string tempB = tempA;
			tempB.replace(tempB.find("avg"), 3, argu + ".avg");
			agg.replace(agg.find(tempA), tempA.length(), tempB);
			second += tempB.length() - tempA.length();
		}
	}
	first = 0;
	while(agg.find("=", first) != -1 && agg.find(">", first) == -1 && agg.find("<", first) == -1)
	{
		first = agg.find("=", first);
		agg.replace(first, 1, "==");
		first += 2;
	}
	first = 0;
	while(agg.find("<>", first) != -1)
	{
		first = agg.find("<>", first);
		agg.replace(first, 2, "!=");
	}
	return agg;
}



